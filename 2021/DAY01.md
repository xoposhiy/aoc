# Ищем интересное в AoC 2021 

## Day 1. Depth increase

Чо за простая задача, скукота, пара циклов и готово, не интересно совсем, пойду лучше реддит почитаю.
Ох, завалили реддит своими решениями с циклами, как тут интересное то найти теперь?! Ладно, нашёл вроде кое-чего.

### Слайсы

Пионер слайсов — Python, конечно. Удобно, компактно, главное как-то умудриться запомнить, что правая граница слайса не включительная.

`sum(sum(input[i:i+3]) < sum(input[i+1:i+4]) for i in range(0, len(input)-3))`

В C# тоже слайсы есть, только ими, никто не пользуется:

`Range(0, input.Length-3).Count(i => input[i..(i+3)].Sum() < input[(i+1)..(i+4)].Sum())`

В Kotlin тоже никто слайсами не пользуется, надо проверить, есть ли они там вообще!
Оп, есть, только свои, самобытные — правая граница диапазонов у них включительная. Чтобы экс-питонисты страдали, видимо!

`(0..input.size-4).count {input.slice(it..it+2).sum() < input.slice(it+1..it+3).sum()}`

### zip

zip пригождается в обычной работе так же редко, как и часто он оказывается нужным во всяких AdventOfCode.
zip наверняка придумали функциональщики, но в Питоне от тоже есть. Смотрите какая красота с ним получается:

`sum(a < b for a, b in zip(input, input[1:]))`

Оп, и решили первую часть без всяких там циклов.

Кстати, если не торопиться клацать по клавиатуре (как я!), а сначала подумать, то можно придумать, что считать сумму 3-окна вообще не надо. 
Достаточно анализировать только те два элемента, которые меняются при переходе от одного 3-окошка к следующему.
Если всё это осознать, то решение второй задачи получается из решения первой очень просто. Оп:

`sum(a < b for a, b in zip(input, input[3:]))`

Как говорится, найдите 2 отличия от решения первой части! Не можете? Правильно, потому что оно всего одно :)

C# и Kotlin умеют так же. Просто держу в курсе, что не Питоном единым.

`input.Zip(input[3..], (a, b) => a > b).Count(t => t)`

`input.zip(input.drop(3)).count {it.first < it.second}`

### windowed

Вот интересно! Что ни решение на Котлине, то функция windowed. Откуда они все про неё знают? Сишарперы вот даже zip выучить не могут, а Котлиновцы windowed знают. Умные!

С ней и правда миленько получается:

`input.windowed(3).count { it.first() < it.last() }`

Оп, а что это за язык slouch такой? А решение то один в один то же самое, что и на Котлине, только короче, и непонятнее :)

`window 4 | count -<{x < a}`

А вот, например, Rust. В нём тоже вот есть какой-то метод tuple_windows, только не понятно, как он догадывается, какого размера окно использовать.

```
input.tuple_windows()
    .map(|(a, b, c)| a + b + c)
    .tuple_windows()
    .filter(|(a, b)| b > a)
    .count()
```

Откуда? В смысле?! Что прямо из системы типов? Компилятор выводит?! Глядя на использование _результата_ этой функции?! А что, так можно было?!?! У нас в сишарпах и джавах так не принято...

Вот чего нет в itertools Python, того нет! Хотя погодите...

`sum(w[0] < w[-1] for w in more_itertools.windowed(input, 4))`

### Векторные операции

windowed, zip — это всё какое-то слишком программистское. Настоящие математики мыслят векторами! Вот Matlab, например:

```
sum(diff(input) > 0)
Y = input(1:end-3);
X = input(4:end);
sum(X-Y > 0)
```

Вычесть из вектора X вектор Y поэлементно, а потом поэлементро же сравнить результат с нулём и получить вектор результатов! О, да! МАТЕМАТИЧНО!

R ещё на полшага дальше ушел — там ты уже себя не только программистом перестаёшь чувствовать, но и математиком тоже. Просто внимательный читатель документации по стандартным функциям, а не программист :)

```
sum(diff(input) > 0)
sum(diff(input, lag=3) > 0)
```

Python забавный парень, и то у него есть и это. Вот и сейчас, добавляешь в него numpy и он тоже математичным становится:

```
np.sum(np.diff(input) > 0)
np.sum(np.diff(input[:-2] + input[1:-1] + input[2:]) > 0)
```

Гм... А знаете у кого ещё есть слайсы и векторные операции? 

```
COUNT(INPUT(1:N-3).LT.INPUT(4:N))
```
 
FORTRAN! Современный язык, оказывается, только ОРАТЬ.ТО.ЗАЧЕМ?

### Alien Programming Languages

Можно было бы ещё поразбираться в решениях на J, K, и прочих APL, но их я не перевариваю :)
Решения на Lisp, Haskell и других FP ничего принципиально нового не показали.
Поэтому закончим первый день на этом!
