# Ищем интересное в AoC 2021 

## Day 1. Depth increase

Чо за простая задача, скукота, пара циклов и готово, не интересно совсем, пойду лучше реддит почитаю.
Ох, завалили реддит своими решениями с циклами, ладно сишники, но CommonLisp, awk, perl — вы то куда? 
Зачем выбирать perl, если собираешься писать банальные сишные циклы?!

Ладно, чего тут интересного есть среди завала циклов?

### Слайсы

Крутые штуки, для работы со скользящими окнами.

Пионер слайсов — Python, конечно, главное помнить, что правая граница слайса не включительная.

`sum(sum(ds[i:i+3]) < sum(ds[i+1:i+4]) for i in range(0, len(ds)-3))`

В C# тоже слайсы есть, только ими чёт, никто не пользуется:

`Range(0, input.Length-3).Count(i => input[i..(i+3)].Sum() < input[(i+1)..(i+4)].Sum())`

В Kotlin тоже никто слайсами не пользуется, надо проверить, есть ли они там вообще!
Оп, есть, только свои, самобытные — правая граница диапазонов у них включительная. Чтобы экс-питонисты страдали, видимо!

`(0..input.size-4).count {input.slice(it..it+2).sum() < input.slice(it+1..it+3).sum()}`

### zip

Удивительно редко zip пригождается в обычной рутине, и удивительно часто он оказывается нужным во всяких AdventOfCode.
Зато вон какая красота получается с ним:

`sum(a < b for a, b in zip(input, input[1:]))`

и решили первую часть без всяких циклов.

Кстати, если не торопиться клацать по клавиатуре (как я!), а сначала подумать, то можно придумать, что считать сумму 3-окна вообще не надо. 
Достаточно анализировать только те два элемента, которые меняются при переходе от одного 3-окошка к следующему.
Если всё это осознать, то решение второй задачи получается из решением первой очень просто. Оп:

`sum(a < b for a, b in zip(input, input[3:]))`

Как говорится, найдите 2 отличия! Не можете? Правильно, потому что оно всего одно :)

C# и Kotlin так же умеют:

`input.Zip(input[3..], (a, b) => a > b).Count(t => t)`

`input.zip(input.drop(3)).count {it.first < it.second}`

### windowed

Что ни решение на Котлине, то функция windowed. Откуда они все про неё знают, не понятно. Сишарперы вот zip выучить не могут, а Котлиновцы windowed знают :\

С ней и правда миленько получается:

`input.windowed(3).count { it.first() < it.last() }`

Оп, А это что за slouch ещё такой? А решение то один в один то же самое, что и на Котлине, только короче, и непонятнее :)

`window 4 | count -<{x < a}`

А вот, например, Rust. В нём тоже вот есть какой-то метод tuple_windows, только не понятно, как он догадывается, какого размера окно использовать. В смысле из системы типов? Что правда?! O_o

```
input.tuple_windows()
	.map(|(a, b, c)| a + b + c)
    .tuple_windows()
    .filter(|(a, b)| b > a)
    .count()
```

Наконец-то есть что-то, чего нет в Python! Или есть? Ох, ты ж...

`sum(w[0] < w[-1] for w in more_itertools.windowed(input, 4))`

### Векторные операции

windowed, zip — это всё какое-то слишком программистское. Настоящие математики мыслят векторами!
```
sum(diff(input) > 0)
Y = input(1:end-3);
X = input(4:end);
sum(X-Y > 0)
```

Вычесть вектора, сравнить вектор поэлементно с 0, получить в результате вектор ответов! МАТЕМАТИЧНО!

R ещё на полшага дальше ушел — там ты уже себя не только программистом перестаёшь чувствовать, но и математиком тоже. Просто внимательный читатель документации по стандартным функциям, а не программист :)

```
sum(diff(input) > 0)
sum(diff(input, lag=3) > 0)
```

А знаете у кого ещё есть слайсы, векторные операции? 

```
COUNT(INPUT(1:N-3).LT.INPUT(4:N)
```
 
FORTRAN! Я в шоке! Современный язык, оказывается, только ОРАТЬ ТО ЗАЧЕМ?

Так, у меня снова Python! 
Что-то он вообще берегов не чует. Что не возьми — в питоне тоже так можно, оказывается.
Вот и тут — берем numpy, и он уже тоже математичный!

````
print(np.sum(np.diff(input) > 0))
print(np.sum(np.diff(input[:-2] + input[1:-1] + input[2:]) > 0))
```

Разбираться в решениях на K, J, Vim и прочих Alien Programming Language, я что-то не очень хочу, поэтому на этом закончим :)