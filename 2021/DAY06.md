# Ищем интересное в AoC 2021 

## Day 6. Lanternfish

Условие: https://adventofcode.com/2021/day/6

Решения: правильное → однострочное → умное → заумное → магическое

### Правильное: Циклический сдвиг массива

Положим в counts в i ячейку количество рыб с кулдауном размножения равному i.

Тогда всё просто: 

```ruby
(0...days).each do |d|
    newFish = counts.shift
    counts[6] += newFish
    counts.push(newFish)
end

counts.reduce(:+)
```

### Однострочное: numpy и reduce

Можно ли сделать из этой идеи oneliner? Да, если суметь сделать две вещи:
1. посчитать counts в одно выражение
2. в одно выражение упаковать свдиг массива и добавление числа в шестую ячейку.

Немного шаманства с numpy и готово:

```python
def numpy_solve(cooldowns, days):
    counts = np.unique(cooldowns + list(range(0, 9)), return_counts=True)[1] - [1] * 9
    for _ in range(days):
        counts = np.roll(counts, -1) + counts[0] * np.eye(9, dtype=int)[6]
    return counts.sum()
```

До oneliner-а остался последний шаг — замена цикла на reduce:

```python
def oneliner(cooldowns, days):
    return functools.reduce(lambda counts, _: np.roll(counts, -1) + counts[0] * np.eye(9, dtype=int)[6], range(days), np.unique(cooldowns + list(range(0, 9)), return_counts=True)[1] - [1] * 9).sum()
```

### Умное: Зачем вращать массив, если можно вращать весь мир вокруг массива?

```python
def smart_solve(cooldowns, days):
    counts = [0] * 9
    for c in cooldowns:
        counts[c] += 1
    for t in range(days):
        counts[(7 + t) % 9] += counts[t % 9]
    return sum(counts)
```

### Заумное: На этот раз не комплексные числа, а матрицы!

Для тех, кто знает, как считать число фиббонначчи за log(N) ничего объяснять не надо.

Для остальных... ох... попробую супер кратенько, надеюсь вы сдюжите.

Получение следующего массива counts из предыдущего можно представить 
в виде умножения вектора исходного counts на матрицу M.

```
next_counts = M * counts
```

Вы ещё помните, как умножать вектор на матрицу? 
Как только вспомните, то сможете несложно подобрать коэффициенты матрицы этой матрицы M, 
они будут вот такие:

```
0 1 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 
0 0 0 0 0 0 1 0 0 
1 0 0 0 0 0 0 1 0 
0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0

```

С помощью numpy несложно собрать такую матрицу:

```python
matrix = np.roll(np.eye(9, dtype=object), 1, 1)
matrix[6][0] = 1
```

А имея матрицу, ответ на задачу можно посчитать многократно умножая исходный counts на неё: 

```
last_counts = M * (M * (...(80 раз)... * (M * (M * counts))...)
answer = sum(last_counts))
```

Важный факт из линалга: умножение матриц ассоциативно (то есть можно переставлять скобки как угодно). 
А значит можно записать это через возведение матрицы M в степень:

```
last_counts = M^256 * counts
```

А для возведения чего-то в степень есть так называемый "быстрый алгоритм".

```
M^256 = (M^64)^2 = ((M^32)^2)^2 = (...(M^2)^2 ... )^2
```
Ещё помните важный факт из линалга про скобки? Вот мы тут фактически перерасстановкой скобок и занимаемся!

В итоге вместо 255 умножений можно сделать 8 возведений в степень. Что, как бы быстро.

Если всё это собрать вместе, получается так:

```python
def matrix_solve(cooldowns, days):
    counts = [0] * 9
    for c in cooldowns:
        counts[c] += 1
    matrix = np.roll(np.eye(9, dtype=object), 1, 1)
    matrix[6][0] = 1
    return np.dot(np.linalg.matrix_power(matrix, days), np.array(counts)).sum()
```

### Магическое!

Следующая штука, которую можно заметить, что всё это умножение матриц не зависит от входных данных.
А значит можно посчитать степень М заранее и захардкодить результат в магическими константами.

И ещё одна идея в том, что после всех предыдущих шагов становится несложно уже каждую рыбку из ввода обработать отдельно.
Все эти идеи в сборе могут выглядеть вот так шокирующе:

```python
magics = {
    80: [1401, 1191, 1154, 1034, 950],
    256: [6206821033, 5617089148, 5217223242, 4726100874, 4368232009]
}


def precalc_solve(cooldowns, days):
    return sum(cooldowns.count(cooldown) * magic for cooldown, magic in enumerate(magics[days], 1))
```

╰( ͡° ͜ʖ ͡° )つ──☆*:・ﾟ


---

Автор большинства сниппетов (или идей этих сниппетов) выше не я — они взяты [из реддита](https://www.reddit.com/r/adventofcode/) твиттера или нашего [телеграм чата](https://t.me/konturAoC2021_chat).
