# aoc2020


## Чему научился

Day 1 Sum. Для задачи 3-sum есть квадратичное решение за O(1) доп-памяти, которое спрашивают на интервью в гугл :))

Day 2 Passwords. Хранить инпут прямо в коде с помощью многострочных строк. `"""input"""`

Day 3 Slopes. Считать количество подходящих элементов в списке с помощью sum: `sum(condition(x) for x in somelist)`

Day 4 Passports. Не забывать $ или \b в регулярках, чтобы прерывать их в нужном месте. Делать красиво проверку на диапазон: `if 10 <= x <= 100`

Day 5 Boardingpass. Парсить бинарную запись числа `int("01001001", 2)`. `"FBBBF".translate("".maketrans("FB","01"))`. Вычитать set-ы. `set(x) - set(y)`

Day 6 Questions. Передавать список аргументов в функцию от нескольких аргументов. `set.intersect(*list_of_sets)`

Day 7 Luggage. 

* Установил PyCharm. Оказывается все это время я злостно нарушал PEP8! :)
* re.split не умеет пропускать пустые элементы :(
* `s[i:-1]` — это вовсе не "от i и до конца строки". Правильно `s[i:]` :(
* Отлаживать вложенные list comprehensions по сложным вложенным структурам данных почти невозможно :( А вот старый добрый for пишется с первого раза.
* Что возвращают сложные регулярки с множеством групп - так и остается загадкой. На любом языке программирования :( Когда-нибудь нужно разобраться в этом до конца! :)
* В большинстве случаев, когда в голову приходит "BFS!", на самом деле хватит простенького рекурсивного DFS.

Day 8 Boot. Началась неделя C#

* Последняя версия Resharper ещё не умеет фичи C# 9. Надо ставить EAP.
* В VS Code можно прилично себе жить с C# 9. Рефакторингов не хватает, немного, но в целом норм.
* Top level statements в C# 9 для AoC не удобны. Нужно много точек входа :( А очень хотелось!
* switch expression красив!

Day 9 Weakness. Хорошо обходиться без возни с индексами там, где это можно!

Day 10 Joltage. Внезапно, хорошо [пригодился](https://github.com/xoposhiy/aoc2020/blob/main/10_joltage.cs#L17) малоизвестный всем ToLookup.
Удивительно много различных способов решить вторую часть задачи! Собрал все интересные у себя :)

Интересное решение с комбинаторикой и числами трибоначчи, для которого надо было осознать структуру графа возможных соединений:
![graph](10.png)

Day 11 Seats. Есть оптимальное решение за O(W x H) для первой части! Для второй можно сделать аналогично, но уже лень.

Day 12 Ferry. Оказалось, что если сразу моделировать все data record-ами в C#, то получается даже быстрее, чем если возиться с Tuple-ами.
Не хватает примитива Vector с операциями сложения и поворота. Надо будет притащить их из других проектов на всякий случай :)

Day 13 Busses. Китайская теорема об остатках! Онлайн-калькулятор для нее!

Day 14 Memmasks. [ПЕРЕБОР ПОДМАСОК](https://e-maxx.ru/algo/all_submasks)! 
Впрочем аналог BFS для перебора всех значений подходящих по маске оказался хоть и длинным, но достаточно простым, чтобы сходу реализовать без ошибок.

Day 15 Don't know sequence. Van Eck sequence. https://www.youtube.com/watch?v=etMJxB-igrc&ab_channel=Numberphile
Странная задача. Простая, но супер сложно написать ее сразу без ошибки.

Day 16 Tickets. Визуализировать промежуточные данные в процессе решения - хорошо! Records в C# ничуть не снижают скорость, но помогают не запутываться.

Day 17 Conway. Чего я меньше всего ожидал от этой задачи, что в чате подскажут новый супер-короткий способ решать игру жизнь! О-гонь!

Day 18 Algebra. Наконец, реализовал вычисление с помощью обратной польской нотации. 
Альтернативное решение с регулярками получлось довольно элегантным (хоть и O(n²))

Day 19 Grammar. Balancing groups в регулярках! O_o (?'open'<)+(?'closed-open'>)+

Day 20 Monsters. Поворот + флип генерируют все 8 преобразований квадрата в себя. Мерзенькая техника, страшненький код.

Day 21. Allergens. Пригодилась идея из Day 16 Tickets. Пришлось повторить в коде. Может быть обобщить как-то этот примитив?

Day 22. Recursive Combat Game. Не сообразил сразу, что rolling hash делать не обязательно :( А ведь легко было: операции старта игры и окончания игры все равно линейные, 
как там не старайся с rolling hash-ем.